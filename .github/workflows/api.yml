# API testing workflow config for CI/CD on Github

name: API continuous integration

# Controls when the action will run.
on:
  # Triggers the workflow on any git push
  push:
  # Triggers workflow for any branch on pull requests
  pull_request:
    branches:
      - '**'
  # Allows running this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow is defined of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "api_test"
  api_test:
    strategy:
      # don't cancel other jobs if one fails
      fail-fast: false
      # tests must be run on both Ubuntu & macOS
      matrix:
        os: [ubuntu, macos]

    runs-on: ${{ matrix.os }}-latest

    # Environment variables available to every step
    env:
      # Skip installing production gems (e.g., pg)
      BUNDLE_WITHOUT: production

      # Run app in test environment
      RACK_ENV: test

      # SQLite database file for tests
      DB_FILENAME: ${{ secrets.DB_FILENAME }}
      DATABASE_URL: sqlite://${{ github.workspace }}/${{ secrets.DB_FILENAME }}

      # AWS & SQS configuration for Shoryuken background worker
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      SQS_QUEUE_URL: ${{ secrets.SQS_QUEUE_URL }}
      SQS_QUEUE_NAME: ${{ secrets.SQS_QUEUE_NAME }}

      # Session secret for Rack
      SESSION_SECRET: ${{ secrets.SESSION_SECRET }}

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE
      - uses: actions/checkout@v4
    
      # Sets up Ruby with Bundler caching
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1 # Corrected indentation
        with:
          bundler-cache: true

      - name: Set up Python
        uses: actions/setup-python@v5 # Corrected indentation
        with: 
          python-version: '3.11'
          cache: 'pip' # caching pip dependencies
      
      - name: Create Python virtualenv & install requirements
        run: |
          python -m venv venv
          ./venv/bin/pip install --upgrade pip
          ./venv/bin/pip install -r requirements.txt
      
      # install pytorch indepently since it is platform-specific
      - name: Install PyTorch
        run: |
          if [ "${{ matrix.os }}" == "ubuntu" ]; then
            ./venv/bin/pip install torch==2.7.0+cpu --index-url https://download.pytorch.org/whl/cpu
          elif [ "${{ matrix.os }}" == "macos" ]; then
            ./venv/bin/pip install torch==2.7.0 --index-url https://download.pytorch.org/whl/cpu
          fi

      # Add Python virtual environment to PATH for subsequent steps
      - name: Add Python venv to PATH
        run: echo "${{ github.workspace }}/venv/bin" >> $GITHUB_PATH # Corrected path and use of GITHUB_PATH

      # same as bin/post_compile for heroku
      - name: Run post-compile script
        run: |
          if [ -f bin/post_compile ]; then
            echo "Running bin/post_compile..."
            chmod +x bin/post_compile
            bin/post_compile
          else
            echo "No bin/post_compile found, skipping."
          fi

      # Debug: Verify important variables exist
      - name: Debug Environment Variables
        run: |
          echo "Workspace: ${{ github.workspace }}"
          echo "DB Filename: $DB_FILENAME"
          echo "DATABASE_URL: $DATABASE_URL"
          echo "AWS Region: $AWS_REGION"
          echo "Queue Name: $SQS_QUEUE_NAME"
          # Verify python is on PATH and correctly linked to venv
          which python
          python --version

      # Ensure database directory exists (SQLite needs it)
      - name: Ensure database directory exists
        run: mkdir -p $(dirname "${{ env.DB_FILENAME }}") # Use env.DB_FILENAME for consistency or secrets.DB_FILENAME directly

      # Debug secret length
      - name: Verify Secret Length
        run: echo "The session secret length is ${{ secrets.SESSION_SECRET.length }}"

      # Run database migrations for testing
      - name: Setup test database
        run: bundle exec rake db:migrate

      # Shoryuken worker in background for parallel job processing
      # Worker must be running so specs can publish messages to SQS
      - name: Start test worker
        run: |
          echo "Starting Shoryuken worker in background..."
          # Using "nohup" and "setsid" can help prevent the process from being killed
          # when the parent shell exits, though for CI, a simple & is often sufficient
          # if the job completes quickly. Consider 'bundle exec shoryuken -C config/shoryuken.yml -r ./config/environment.rb &'
          # or however your shoryuken worker is typically started.
          bundle exec rake worker:run:test &
          # Capture the PID to kill it later if necessary, though GitHub actions
          # generally clean up processes at job end.
          WORKER_PID=$!
          echo "Shoryuken worker started with PID: $WORKER_PID"
          # Wait a moment to ensure worker boots before running tests
          sleep 5 # Increased sleep slightly
          # Store PID in an environment variable for potential later cleanup
          echo "WORKER_PID=$WORKER_PID" >> $GITHUB_ENV

      - name: Run all specs
        run: bundle exec rake spec
      
      # Optional: Clean up the worker process if it was started in the background
      # This step might not be strictly necessary as GitHub Actions usually clean up.
      - name: Stop test worker (optional cleanup)
        if: always() && env.WORKER_PID # Run if job completes, even if tests failed
        run: |
          echo "Attempting to stop Shoryuken worker with PID: ${{ env.WORKER_PID }}"
          kill ${{ env.WORKER_PID }} || true # '|| true' prevents step from failing if process already gone